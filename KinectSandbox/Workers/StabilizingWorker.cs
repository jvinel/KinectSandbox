using KinectSandbox.Filters;
using Microsoft.Kinect;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace KinectSandbox.Workers
{
    /// <summary>
    /// StabilizingWorker main goals is to cleanup Depth Frame received from a kinect device.
    /// </summary>
    public class StabilizingWorker : DataFilter
    {
        /// <summary>
        /// Cleanupped depth frame
        /// </summary>
        private DepthImagePixel[] tempData;
        /// <summary>
        /// Minimum variation of depth for a specified point. Every variation below this threshold will be ignored
        /// </summary>
        private short MinVariance { get; set; }
        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="dataFilterInput"></param>
        public StabilizingWorker(DataFilterInput dataFilterInput)
            : base(dataFilterInput)
        {
            this.MinVariance=5;
        }

        /// <summary>
        /// Convert a DepthImagePixel array to a bitmap.
        /// Bitmap is colorize if a gradient bitmap has been set, isolines are also added as an overlay
        /// </summary>
        /// <param name="sourceData">DepthImagePixel array (generated by Kinect device depth sensor)</param>
        protected override void Process(DepthImagePixel[] sourceData)
        {
            if ((tempData == null) || (tempData.Length!=sourceData.Length))
            {
                // Initialize buffer
                tempData = new DepthImagePixel[sourceData.Length];
                

            }

            for (int i = 0; i < sourceData.Length; i++)
            {
                short newValue = sourceData[i].Depth;
                short oldValue = tempData[i].Depth;
                    if (isValid(newValue))
                    {
                        // New value is valid
                        if (isValid(oldValue))
                        {

                            // If previous result was also valid, then check that minimun variance is reached
                            if (Math.Abs(newValue - oldValue) > this.MinVariance)
                            {
                                tempData[i].Depth = newValue;
                            } // Otherwise we keep the previous value

                        }
                        else
                        {
                            // New value is valid, but previous result invalid, we keep the new value
                            tempData[i].Depth = newValue;
                        }

                    }
                    
                }

            // Pass bitmap generated to UI (or other filter)
            OnDataReady(new DataReadyEventArgs(tempData));
        }
        /// <summary>
        /// Check if depth specified is valid (between Min Depth and Max Depth settings)
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        private bool isValid(short value)
        {
            if ((value >= this.MinDepth) && (value <= this.MaxDepth))
            {
                return true;
            }
            return false;
        }
    }
}
